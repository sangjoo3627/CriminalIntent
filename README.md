2. CriminalIntent 앱 시작

(7) UI 프래그먼트와 프래그먼트 매니저
- 액티비티는 UI의 유연성에서 불리하다. 즉 사용자에 의해 사용되는 특정 화면과 강하게 결속된다
- 예를들어 두가지의 액티비티(리스트-디테일)가 있을때, 리스트에서 디테일을 눌러 보고 있으면서 리스트에 나온 다음 디테일의 내용을 보고 싶을경우 리스트로 돌아가지 않고 바로 다음 디테일을 보게하도록 할때

- 프래그먼트 개요
- 액티비티에서 하나 이상의 프래그먼트로 앱의 UI를 관리하면 유연성을 더 좋게할 수 있다
- 프래그먼트는 액티비티의 작업 수행을 대행 할 수 있는 컨트롤러 객체이다. 여기서 작업이라함은 사용자 인터페이스 관리를 말함
- 사용자 인터페이스를 관리하는 프래그먼트를 UI 프래그먼트라 한다
- 즉 UI 프래그먼트를 사용하면 앱의 UI를 조립 가능한 요소로 분리할 수 있다. -> 재사용성 증가

- 프래그먼트가 자신의 뷰를 둘 수 있는 장소를 액티비티가 제공하는 것을 호스팅이라함
- 프래그먼트는 화면에 나타나는 뷰를 자체적으로 가질 수 없고 액티비티의 뷰 계층에 포함될 때만 자신의 뷰가 화면에 나타남
- 호스팅 하려면 액티비티는 반드시 다음 두가지를 해야함
- 액티비티 자신의 레이아웃에 프래그먼트의 뷰를 넣을 위치를 정의, 프래그먼트 인스턴스의 생명주기를 관리
- 호스팅의 두가지 방법
- 프래그먼트를 액티비티의 레이아웃에 정적으로 추가(간단하지만 유연하지 못함), 프래그먼트를 액티비티의 코드에 동적으로 추가 (런타임시에 프래그먼트 제어 가능)

- 액티비티 xml에 FrameLayout을 생성
- Fragment xml을 생성 후 모양을 잡아줌
- Crime class 생성
- CrimeFragment class 생성 : extends Fragment 추가
- Fragment의 onCreate()와 생명주기 메서드들은 모두 public이어야함 -> 호스팅하는 어떤 액티비티에서 호출되어야하기 때문
- 또 onCreateView를 따로 구현하여 EditText 변수로 addTextChangedListener를 추가한다

- 이제 UI 프래그먼트를 프래그먼트매니저에 추가해야한다
- 액티비티에 프래그먼트매니저를 생성하고 프래그먼트를 리소스 id로 가져옴
- fm.beginTransaction() .add() 와 .commit() 로 프래그먼트 트랜잭션을 생성하고 그 인스턴스에 프래그먼트 객체를 추가한 후 커밋한다
- 프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가/삭제/첨부/분리/변경 하는데 사용되고
- 프래그먼트를 사용해서 런타임 시에 화면을 구성 또는 재구성하는 방법이 프래그먼트 트랜잭션이다

- 프래그먼트 매니저와 프래그먼트 생명주기
- fm은 자신의 리스트에 있는 프래그먼트들의 생명주기 메서드를 호출하는 책임을 가지고 있다
- onActivityCreate() 메서드는 호스팅 액티비티의 onCreate()가 실행된 후 호출됨

- 프래그먼트는 주요 컴포넌트를 재사용 가능한 방법으로 캡슐화하기 위한 목적이다
- 즉 세세한 것까지 다 프래그먼트로 만들어버리면 수많은 트랜잭션을 처리하느라 지저분해진다
- 한 화면에는 최대 두세개의 프래그먼트 정도가 적당하다
- 프래그먼트를 사용하는 이유는 다양하지만 그냥 프래그먼트를 써라!!
- 이 책에서는 지원 라이브러리의 프래그먼트를 사용했는데 이건 과거 버전의 안드로이드 개발자들이 프래그먼트를 사용할 수 있도록 하기 위해 만들어진 것임
- 딱히 단점은 없지만 요즘 안드로이드 버전의 표준 라이브러리 프래그먼트가 다 포함되어있긴하다


(8) 레이아웃과 위젯으로 사용자 인터페이스 생성하기
- 범죄의 날짜와 상태를 앱에 추가할 것임
- Date, SolvedCheckBox 멤버변수를 추가
- dp는 밀도 독립적 픽셀의 줄임말로 서로 다른 화면 픽셀 밀도에 맞게 자동으로 이미지 크기를 조정한다. 마진이나 패딩의 크기를 설정할 때 사용
- sp는 크기 독립적 픽셀의 줄임말로 주로 화면에 나타나는 텍스트 크기를 설정할 때 사용
- 레이아웃 속성중 layout_이 붙는 속성들은 그 위젯의 부모에 지시를 하는 것이고 => 이런것들을 레이아웃 매개변수라함
- layout_ 이 없는 속성들은 그 위젯에 지시를 하는 것
- 마진은 레이아웃 매겨변수고 패딩은 아님



* 4일차

- 화면을 회전시켰을때 나오는 화면 배치를 다르게 하고 싶을경우,
- xml에서 원하는 방향에 맞는 xml을 바로 추가시켜줄 수 있다 (ex lanscape 등)
- Android:layout_weight 의 사용처 : LinearLayout에 자식들을 배치하는 방법을 알려주며 위젯들에게 weight(가중치) 값을 주어 넓이를 결정한다
- 이때 layout_width(or layout_height)와 layout_weight를 섞어서 사용해야함
- layout_width를 0dp로 하면 각 위젯의 콘텐츠 크기와 상관없이 가중치만 가지고 자리를 차지하는것


(9) RecyclerView로 리스트 보여주기
- 이제 디테일 화면 말고 범죄의 리스트를 보여주는 화면을 새로이 구성할 것임
- 먼저 Crime 객체 하나만 처리하던 것을 다수의 Crime 객체 리스트 (CrimeLab)로 처리하도록 변경함 -> 리스트를 싱글톤에 저장
- 싱글톤은 딱 하나의 인스턴스만 생성 할 수 있는 클래스

- 프래그먼트의 호스팅을 위한 추상 액티비티
- 특별히 코드를 바꿀것이 없는 보편적인 코드는 재사용할 가능성이 크므로 이 코드를 추상 클래스에 넣어 같은 코드를 여러번 다시 입력하지 않도록한다
- 추상 클래스를 따로 하나 생성하고 실제 코드에서는 이 추상클래스를 extends로 상속받고 필요한 부분만 오버라이드 해준다

- 이제 새로운 화면을 위한 새로운 컨트롤러 클래스를 생성시작
- CrimeListActivity.java, CrimeListFragment.java 들을 생성하고 CrimeListActivity는 매니페스트에 선언
- CrimeListActivity를 런처 액티비티로 선언

- CrimeListFragment에서 범죄리스트를 사용자에게 보여주기 위해 RecyclerView를 사용
- RecyclerView는 ViewGroup의 서브 클래스로 자식 View 객체들의 리스트를 보여줌
- 우리 앱은 리스트에서 범죄의 제목만 보여줄 것이므로 자식 View 객체는 TextView 하나면 족하다
- RecyclerView는 한꺼번에 모든 View를 생성하는 것이 아닌 필요할 때만 View 객체를 생성할 수 있다
- 즉 한 화면을 채우는데 충분한 12개 정도만 먼저 생성하고 스크롤을 내려 View가 화면을 벗어나면 RecyclerView는 그 View를 버리지 않고 재활용한다

- 여기서 우리가 필요한 TextView를 얻으려면 Adapter의 서브 클래스와 ViewHolder의 서브 클래스가 함께 동작해야한다
- 먼저 ViewHolder는 하나의 View를 보존하는 일을 한다
- ViewHolder는 자신의 itemView로 View 객체를 가져옴
- RecyclerView는 자신이 ViewHolder를 생성하지 않고 어댑터에 요청한다. 어댑터는 컨트롤러의 객체이고
- 필요한 ViewHolder를 생성해주고 모델 계층의 데이터를 ViewHolder와 결합한다
- 그리고 RecyclerView가 화면에 보여줄 객체를 필요로 할때마다 자신의 어댑터와 소통한다 (메서드를 보내 데이터 요청)

- xml을 새로 만들어 RecyclerView 위젯으로 레이아웃을 구성하고 프래그먼트와 연결시킨다
- 어뎁터와 ViewHolder class 구현하기
- 어댑터에서 View 객체를 생성하고 ViewHolder를 만들어 여기에 넣는다
- 마지막으로 어댑터를 RecyclerView에 연결함

- 리스트항목 디자인을 커스터마이징 하고 싶으면 list_item_crime.xml을 따로 만들고 View들로 내용을 구성한다
- 그 후 추가한 View들을 연결하기 위해 어댑터와 ViewHolder를 수정
- list에 Toast 기능을 넣고 싶으면 ViewHolder에 View.OnClickListener 인터페이스를 impletments시키고
- setOnclickListener(this)를 추가한 후 onClick(View v) 메소드를 오버라이딩 한다


(10) 프래그먼트 인자 사용하기
- 여기서는 앱의 리스트와 디테일 부분이 함께 동작하게 할 것임
- 리스트의 항목을 클릭하면 CrimeFragment를 호스팅 하는 새로운 CrimeActivity가 나타나서 특정 Crime 인스턴스의 디테일을 보여줌
- 이때 명시적인 인텐트를 사용하여 Crime 객체를 인텐트 엑스트라 데이터로 전달할 것임

- 프래그먼트로부터 액티비티 시작시키기
- CrimeActivity에서 인텐트를 생성하고 엑스트라에 Crime의 데이터를 넣은 후
- Fragment.startActivity(Intent) 메서드를 호출하면됨

- 엑스트라 읽기
- 이제 Crime 객체 데이터는 CrimeActivity에 속한 인텐트에 저장되었다
- 하지만 그 엑스트라 데이터를 읽고 쓰는 것은 CrimeFragment이다
- 프래그먼트가 자신의 호스팅 하는 액티비티의 인텐트에 저장된 데이터에 액세스 할 수 있는 방법은 두가지
- 1. 쉽게 직접 엑세스하는법 : getActivity() 메서드를 사용해 인텐트를 바로 엑세스 => 재사용성 불가능
- 2. 복잡하지만 유연한 코드 구현 방법 : 프래그먼트에 속하는 프래그먼트의 인자(argument) 번들에 Crime 데이터를 저장
- 프래그먼트 인자를 생성하려면 우선 Bundle 객체를 생성하고 put 메서드를 사용해서 인자를 추가
- 인자 번들을 프래그먼트에 첨부하려면 Fragment.setArguments(Bundle)을 호출함
- 이를 위해 프래그먼트에 newInstance()라는 static 메서드를 추가하여 프래그먼트 인스턴스와 번들 인스턴스를 생성하고 번들 인스턴스를 프래그먼트 인자로 첨부한다. => 생성자를 직접 호출하는 대신 이 함수를 통해 생성하고 첨부하는 것

- 인자 가져오기
- 프래그먼트가 자신에게 전달된 인자를 엑세스해야할 때는 Fragment 클래스의 메서드인 getArguments()를 호출하고 Bundle의 ‘get’ 메서드들 중 하나를 호출하면 된다

- 여기까지하면 리스트에서 하나의 항목을 눌러 값을 가져올 수 있지만 디테일 화면에서 값을 변경 후 ‘back’ 버튼을 눌러 리스트로 돌아가면
- 변경 사항이 저장되지 않는다
- ‘back’을 누르면 디테일 화면 프래그먼트가 스택에서 꺼내져 소멸되고 다시 CrimeListActivity가 시작(started)되어 재실행(resumed) 되는데
- 재실행 될때 프래그먼트 매니저가 호스팅 하고 있는 프래그먼트들의 onResume()을 호출한다
- 즉 CrimeListFragment의 onResume() 메서드를 오버라이드하여 updateUI()를 호출하도록 수정해야함’

- 프래그먼트로부터 결과 받기
- 프래그먼트는 자신의 결과 값은 가질 수 없고 대신 호스팅 액티비티에 결과 값의 반환을 알려준다



* 6일차

(11) ViewPager 사용하기
- 여기서는 CrimeFragment를 호스팅하는 새로운 액티비티를 생성할 것임 (CrimeActivity를 대체할 것임)
- 이 액티비티의 레이아웃은 하나의 ViewPager 인스턴스로 구성될 것이다 -> 왼쪽이나 오른쪽으로 밀면 전/후의 디테일이 표시되도록하는 기능 (paging)
- 새로운 액티비티 CrimePagerActivity.java와 activity_crime_pager.xml을 생성
- ViewPager도 RecyclerView와 마찬가지로 어댑터가 필요한데 이 경우는 PagerAdapter가 필요함
- FragmentStatePagerAdapter는 액티비티가 아닌 프래그먼트를 사용하는 PagerAdapter를 구현한 것이고 프래그먼트의 상태도 저장/복원 가능하다
- 위의 어댑터의 getCount()와 getItem(int)로 소통함
- CrimePagerActivity에 구현 (RecyclerView는 프래그먼트에 구현하는데 왜 얘는 액티비티에...?)
- FragmentManager를 쓰는 이유는 -> getItem(int)에서 반환하는 프래그먼트를 어댑터가 처리하려면 그것을 우리 액티비티에 추가할 수 있어야하기 때문
- FragmentStatePagerAdapter는 뷰페이저와의 소통을 관리하는 중개자이다.
       => 우리가 반환하는 프래그먼트를 우리 액티비티에 추가하는 역할
- ViewPager가 그 프래그먼트의 뷰가 올바르게 위치할 수 있도록 식별하는 것을 도와주는 것
- 다른 서브 클래스로는 FragmentPagerAdapter가 있는데 다른건 다 같고 프래그먼트를 없애는 방법만 다름
- 즉 프래그먼트가 더이상 필요없게 되면 트랜잭션에서 remove(Fragment)가 아닌 detach(Fragment)를 호출하는데
- 그 프래그먼트의 뷰는 소멸되지만 인스턴스는 여전히 FragmentManager에 남게된다
- FragmentStatePagerAdapter는 프래그먼트를 완전히 삭제되고 Bundle 객체만 보존함
- 우리앱은 많은 양의 데이터 처리를 필요로 하므로 그런 정보를 메모리에 보존하길 원하지 않으므로 FragmentStatePagerAdapter를 사용


(12) 대화상자
- 사용자의 주의를 끌고 입력을 받는데 사용됨
- 여기서는 범죄가 발생한 날짜를 사용자가 변경할 수 있는 대화상자를 추가할 것임
- 대화상자는 Dialog의 서브 클래스인 AlertDialog의 인스턴스이며
- AppCompat라는 라이브러리를 사용하여 새로운 스타일의 대화상자를 보여줄 수 있다
- AlertDialog를 사용할때는 Fragment의 서브클래스인 DiaglogFragment의 인스턴스에 래핑(포함되어 같이 동작하도록)하는 것이 좋음 (권장사항)
- 즉 우리앱에서는 DatePickerFragment라는 DialogFragment 서브 클래스를 생성하고 CrimePagerActivity에 의해 호스팅되게하고
- 그 내부에서 DataPicker 위젯을 보여주는 AlertDialog의 인스턴스를 생성하고 구성할 것임
- AlertDialog.Builder 클래스를 통해 AlertDialog 인스턴스를 생성하는데 필요한 인터페이스 제공

- 다음으로는 AlertDialog.Builder 메서드인 setView(View v)를 사용해 우리의 AlertDialog에 DatePicker를 추가할것임
- 위의 View v는 대화 상자의 제목과 버튼 사이에 보여주기 위한 대화상자를 구성

- 같은 액티비티에 의해 호스팅 되는 두 플래그먼트 간의 데이터 전달방법

- DatePickerFragment에 데이터 전달하기
- 프래그먼트 인자의 생성과 설정
- 프래그먼트 인자로부터 추출한 Date 객체와 Calendar를 사용하여 DatePicker를 초기화 시키는 코드추가

- CrimeFragment로 데이터 반환하기
- CrimeFragment를 DatePickerFragment의 목표 프래그먼트로 만들면 두 프래그먼트 간의 관계를 추적 관리하는 연결을 만들 수 있다
- setTargetFragment 메서드를 이용 (목표 프래그먼트와 요청 코드를 인자로 받음)
- 그런다음 목표 프래그먼트로 데이터를 전달하기 위해서는
- 반환할 날짜를 Intent의 엑스트라로 저장하고 Fragment.onActivityResult()를 호출한다


(13) 툴바
- 툴바에 나타나는 메뉴를 생성해서 사용자가 새로운 범죄를 추가할수 있는 액션 항목을 갖게하고
- 툴바의 UP 버튼도 활성화할것임
- 모든 액티비티를 AppCompatActivity의 서브 클래스로 변경하면
- 앱의 가장 윗줄에 툴바영역이 생긴다

- 이제 툴바의 오른쪽에 액션항목으로 구성된 메뉴를 둔다
- xml로 메뉴 정의
- 이때 메뉴는 시스템 아이콘을 참조하는데 이 시스템 아이콘은 프로젝트의 리소스가 아니라
- 장치에 있는 아이콘이기 때문에 장치에 따라 달라질수있다
- 즉 우리 앱에 어울리지 않은 아이콘이 될 수 있기 때문에 문제가 될수 있다
- 해결방법 : 
    - (1) 우리 나름의 아이콘을 만드는것 (밀도별로 하나씩 만들어야함)
    - (2) 우리 앱의 요구에 맞는 시스템 아이콘을 찾아서 우리 프로젝트의 리소스로 복사하는 것
    - (3) 안드로이드 스튜디오에 포함된 에셋(Asset) 구성 도구를 사용하는 것. 이 도구를 사용해서 툴바에 사용할 이미지를 쉽게 생성가능하다
- 여기서는 3번째 방법을 씀

- 메뉴 생성하기
- 메뉴를 생성하기 위해서 안드로이드는 액티비티 메서드인 onCreateOptionsMenu(Menu)를 호출한다
- 그리고 메뉴 콜백 호출을 받는다는 것을 명시적으로 알려주기 위해 onCreate 함수를 오버라이드해서 
- setHasOptionsMenu(true); 코드를 추가한다

- 메뉴 선택에 응답하기
- 범죄를 추가하려면 CrimeLab 인스턴스에 배열을 추가하는 코드를 넣어야함
- 그런후 사용자가 메뉴의 항목을 넣으면 onOptionsItemSelected(MenuItem) 메서드의 콜백 호출을 받음

- 계층적 네비게이션 활성화 하기 (Up 버튼 구현)
- 현재까지는 “back” 버튼에 의존해 직전에 있던 화면을 이동했음
- Up 버튼을 구현해서 계층적 네비게이션을 구현해야한다
- 메니페스트에서 CrimePagerActivity에 parentActivity를 추가하여 계층적 네비게이션을 활성화한다

- 액션 항목을 하나더 추가해서 (툴바의 서브타이틀을 보게해주는) 구현
- ifRoom 속성을 넣으면 컨텐츠가 보이고, never로 하면 세로 점 세개로 표현된다

- 액션 항목의 제목 토글하기
- Boolean 멤버변수를 하나 추가하고 액션 항목을 두가지 문자열로 토글 시키면서
- 서브타이틀을 추가하거나/감춘다.
- 이때, back 버튼을 눌러 돌아갈때 서브타이틀을 갱신하려면 update 함수에 추가하면되지만
- Up 버튼으로 돌아갈때 유지하도록 구현하는 것은 어렵다
- 마지막으로 장치를 회전시켰을때는 가시성 변수 값이 보존되지 않는데
- 이 문제는 안드로이드 인스턴스 상태 보존 매커니즘을 사용해서 mSubtitleVisible을 보존하면 된다



* 7일차

(14) SQLite 데이터베이스
- 안드로이드 장치의 각 앱은 자신의 샌드박스(sandbox)에 디렉터리를 갖고
- 샌드박스에 파일을 저장하면 다른 앱이나 유저들이 접근하는 것을 막아준다
- ex) /data/data/com.~~~~.criminalintent
- SQLite : 간단한 파일 형태로 데이터를 저장하고 SQLite 라이브러리를 사용해서 데이터를 읽거나 쓸 수 있는 오픈소스 관계형 데이터베이스

- CrimeDbSchema.java에 스키마를 정의한다
- DB를 생성하려면 사전작업이 필요한데 이 사전작업들을 처리 하기 위해 안드로이드는 SQLiteIpenHelper 클래스를 제공한다
- 이 클래스의 서브 클래스로 CrimeBaseHelper 클래스를 생성한다
- 그리고 이 클래스를 CrimeLab에서 사용하여 디비를 생성하도록 수정

- 데이터를 DB에 쓸때는 ContentValues라는 클래스의 도움을 받아 수행
- 키와 값 쌍으로 구성되고 SQLite가 보존할 종류 데이터에 맞게 특별히 디자인됨
- 행 추가하기와 갱신하기 구현

- 데이터를 DB에서 읽을때 SQLiteDatabase.query() 메서드를 사용한다
- 이 메서드는 여러가지 형태로 오버로딩 되어있고, 인자들은 SQL select 명령문을 구성한다
- 그리고 이 쿼리 메서드 결과는 Cursor 인스턴스로 가져와진다
- 커서는 각 열에 사용하여 데이터를 가져오고 테이블 데이터를 읽을 때마다 매번 코드를 작성해야하므로 한 곳에서 이 코드들을 관리해야한다. -> CursorWrapper의 서브 클래스를 정의해서 사용
- 즉 정리하면 query() 메서드를 통해 쿼리를 담은 하나의 cursor를 생성해 가져오고
- 이것을 인자로 CursorWrapper를 생성한 후
- CursorWrapper의 getCrime() 함수를 통해 Crime 객체나 Crimes를 가져온다
- 커서는 쿼리 결과의 특정 지점을 가리키고 moveToFirst(), moveToNext(), isAfterLast() 등의 메서드로 쿼리 결과를 확인한다
- Back 버튼을 눌러서 돌아갈때도 뷰에 업데이트가 되도록 update 함수에 변경된 데이터가 반영되도록 포함시킨다



* 8일차

(15) 암시적 인텐트
- 암시적 인텐트를 사용하면 장치의 다른 애플리케이션에 있는 액티비티를 시작할 수 있다
- 명시적 인텐트에서는 시작시킬 액티비티 클래스를 우리가 지정하면 안드로이드 os가 그 액티비티를 시작시킨다
- 암시적 인텐트에서는 우리가 필요한 작업을 알려주면 그 작업에 적합한 애플리케이션의 액티비티를 안드로이드 os가 찾아서 시작시켜준다
- 우리 앱에서는 암시적 인텐트를 사용해서 사용자의 연락처에서 범죄 용의자를 한명선택해 텍스트 형태의 범죄 보고서를 전송할 수 있게 할 것임

- 일단 용의자 데이터를 Crime 클래스에 추가하고 관련 DB 함수들에도 열을 추가해준다
- 데이터베이스 열을 추가했으면 기존 데이터베이스를 삭제하고 새것으로 교체하는 것이 좋음 (앱 삭제 후 다시 설치하는게 제일 간단)

- 포맷 문자열 사용하기
- 특정 범죄의 상세 정보로 구성되는 범죄 보고서의 템플릿을 생성해야하는데 앱이 실행되기 전까지는 이 상세정보를 알 수 없다 즉 대체 될 수 있는 플레이스 홀더를 갖는 포맷 문자열을 사용해야함
- String.xml에 문자열 리소스 추가하고
- 문자열을 생성한 후 그것들을 결합하여 하나의 완전한 보고서로 반환하는 메서드 getCrimeReport()추가

- 암시적 인텐트 사용하기
- 안드로이드에게 우리가 원하는 작업을 알려주고 안드로이드 os가 앱을 찾아준다
- 암시적 인텐트 구성요소는 액션, 데이터의위치, 액션에 필요한 데이터타입, 선택적으로 사용가능한 카테고리 등으로 구성되어있다

- 범죄 보고서 전송하기
- 범죄 보고서는 문자열이므로 암시적 인텐트의 액션은 ACTION_SEND가 되고 타입은 text/plain
- CrimeFragment.onCreateView에서 범죄 보고서 전송 버튼의 참조를 얻고 리스너를 설정함
- 그리고 그 리스너에서 암시적 인텐트를 생성한 후 그것을 startActivity(Intent)의 인자로 전달함

- 안드로이드에 연락처 요청하기
- 사용자들이 자신들의 연락처로부터 용의자를 선택할 수 있게 해주는 또 다른 암시적 인텐트 생성
- 액션은 Intent.ACTION_PICK이 되고 연락처 데이터베이스에 항목 선택을 요청한다는 뜻임
- 그리고 연락처의 시작된 액티비티로부터 결과를 돌려받아야하는데 startActivityForResult() 메서드 인자로 인텐트와 요청 코드를 전달하여 호출함

- 연락처 리스트에서 데이터 가져오기
- startActivityForResult로 요청했으니 onActivityResult를 통해 인텐트를 돌려받게 됨
- Uri는 하나의 연락처를 가리키는 위치 표시자 (locator)
- 먼저 Uri로 intent에서 getData()로 데이터를 가져온 후
- 값을 반환한 쿼리 필드를 저장한 다음 Uri 값으로 where 절에 넣어 쿼리를 수행함
- 그리고 커서로 첫번째 행의 첫번째 열을 찾아가 용의자 이름을 뽑아낸다

- 만약 사용자가 연락처 앱이 없을 경우는
- 안드로이드 os 일부인 PackageManager를 onCreateView에서 먼저 확인하면된다
- PackageManager는 안드로이드 장치의 모든 컴포넌트와 액티비티를 알고 있다
- resolveActivity(Intent, int) 메서드의 첫 인자로 우리 인텐트를 전달하여 호출하면 그 인텐트와 일치하는 액티비티를 찾아볼 수 있다
- 두번째 인자로 우리가 원하는 플래그를 전달하면 그 플래그를 갖는 액티비티를 대상으로 찾는다 (이 플래그는 액티비티 매니페스트의 인텐트 필터에 저장함)
