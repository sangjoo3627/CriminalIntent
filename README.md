# CriminalIntent

2. CriminalIntent 앱 시작

(7) UI 프래그먼트와 프래그먼트 매니저
- 액티비티는 UI의 유연성에서 불리하다. 즉 사용자에 의해 사용되는 특정 화면과 강하게 결속된다
- 예를들어 두가지의 액티비티(리스트-디테일)가 있을때, 리스트에서 디테일을 눌러 보고 있으면서 리스트에 나온 다음 디테일의 내용을 보고 싶을경우 리스트로 돌아가지 않고 바로 다음 디테일을 보게하도록 할때

- 프래그먼트 개요
- 액티비티에서 하나 이상의 프래그먼트로 앱의 UI를 관리하면 유연성을 더 좋게할 수 있다
- 프래그먼트는 액티비티의 작업 수행을 대행 할 수 있는 컨트롤러 객체이다. 여기서 작업이라함은 사용자 인터페이스 관리를 말함
- 사용자 인터페이스를 관리하는 프래그먼트를 UI 프래그먼트라 한다
- 즉 UI 프래그먼트를 사용하면 앱의 UI를 조립 가능한 요소로 분리할 수 있다. -> 재사용성 증가

- 프래그먼트가 자신의 뷰를 둘 수 있는 장소를 액티비티가 제공하는 것을 호스팅이라함
- 프래그먼트는 화면에 나타나는 뷰를 자체적으로 가질 수 없고 액티비티의 뷰 계층에 포함될 때만 자신의 뷰가 화면에 나타남
- 호스팅 하려면 액티비티는 반드시 다음 두가지를 해야함
- 액티비티 자신의 레이아웃에 프래그먼트의 뷰를 넣을 위치를 정의, 프래그먼트 인스턴스의 생명주기를 관리
- 호스팅의 두가지 방법
- 프래그먼트를 액티비티의 레이아웃에 정적으로 추가(간단하지만 유연하지 못함), 프래그먼트를 액티비티의 코드에 동적으로 추가 (런타임시에 프래그먼트 제어 가능)

- 액티비티 xml에 FrameLayout을 생성
- Fragment xml을 생성 후 모양을 잡아줌
- Crime class 생성
- CrimeFragment class 생성 : extends Fragment 추가
- Fragment의 onCreate()와 생명주기 메서드들은 모두 public이어야함 -> 호스팅하는 어떤 액티비티에서 호출되어야하기 때문
- 또 onCreateView를 따로 구현하여 EditText 변수로 addTextChangedListener를 추가한다

- 이제 UI 프래그먼트를 프래그먼트매니저에 추가해야한다
- 액티비티에 프래그먼트매니저를 생성하고 프래그먼트를 리소스 id로 가져옴
- fm.beginTransaction() .add() 와 .commit() 로 프래그먼트 트랜잭션을 생성하고 그 인스턴스에 프래그먼트 객체를 추가한 후 커밋한다
- 프래그먼트 트랜잭션은 프래그먼트 리스트에 프래그먼트를 추가/삭제/첨부/분리/변경 하는데 사용되고
- 프래그먼트를 사용해서 런타임 시에 화면을 구성 또는 재구성하는 방법이 프래그먼트 트랜잭션이다

- 프래그먼트 매니저와 프래그먼트 생명주기
- fm은 자신의 리스트에 있는 프래그먼트들의 생명주기 메서드를 호출하는 책임을 가지고 있다
- onActivityCreate() 메서드는 호스팅 액티비티의 onCreate()가 실행된 후 호출됨

- 프래그먼트는 주요 컴포넌트를 재사용 가능한 방법으로 캡슐화하기 위한 목적이다
- 즉 세세한 것까지 다 프래그먼트로 만들어버리면 수많은 트랜잭션을 처리하느라 지저분해진다
- 한 화면에는 최대 두세개의 프래그먼트 정도가 적당하다
- 프래그먼트를 사용하는 이유는 다양하지만 그냥 프래그먼트를 써라!!
- 이 책에서는 지원 라이브러리의 프래그먼트를 사용했는데 이건 과거 버전의 안드로이드 개발자들이 프래그먼트를 사용할 수 있도록 하기 위해 만들어진 것임
- 딱히 단점은 없지만 요즘 안드로이드 버전의 표준 라이브러리 프래그먼트가 다 포함되어있긴하다


(8) 레이아웃과 위젯으로 사용자 인터페이스 생성하기
- 범죄의 날짜와 상태를 앱에 추가할 것임
- Date, SolvedCheckBox 멤버변수를 추가
- dp는 밀도 독립적 픽셀의 줄임말로 서로 다른 화면 픽셀 밀도에 맞게 자동으로 이미지 크기를 조정한다. 마진이나 패딩의 크기를 설정할 때 사용
- sp는 크기 독립적 픽셀의 줄임말로 주로 화면에 나타나는 텍스트 크기를 설정할 때 사용
- 레이아웃 속성중 layout_이 붙는 속성들은 그 위젯의 부모에 지시를 하는 것이고 => 이런것들을 레이아웃 매개변수라함
- layout_ 이 없는 속성들은 그 위젯에 지시를 하는 것
- 마진은 레이아웃 매겨변수고 패딩은 아님



* 4일차

- 화면을 회전시켰을때 나오는 화면 배치를 다르게 하고 싶을경우,
- xml에서 원하는 방향에 맞는 xml을 바로 추가시켜줄 수 있다 (ex lanscape 등)
- Android:layout_weight 의 사용처 : LinearLayout에 자식들을 배치하는 방법을 알려주며 위젯들에게 weight(가중치) 값을 주어 넓이를 결정한다
- 이때 layout_width(or layout_height)와 layout_weight를 섞어서 사용해야함
- layout_width를 0dp로 하면 각 위젯의 콘텐츠 크기와 상관없이 가중치만 가지고 자리를 차지하는것


(9) RecyclerView로 리스트 보여주기
- 이제 디테일 화면 말고 범죄의 리스트를 보여주는 화면을 새로이 구성할 것임
- 먼저 Crime 객체 하나만 처리하던 것을 다수의 Crime 객체 리스트 (CrimeLab)로 처리하도록 변경함 -> 리스트를 싱글톤에 저장
- 싱글톤은 딱 하나의 인스턴스만 생성 할 수 있는 클래스

- 프래그먼트의 호스팅을 위한 추상 액티비티
- 특별히 코드를 바꿀것이 없는 보편적인 코드는 재사용할 가능성이 크므로 이 코드를 추상 클래스에 넣어 같은 코드를 여러번 다시 입력하지 않도록한다
- 추상 클래스를 따로 하나 생성하고 실제 코드에서는 이 추상클래스를 extends로 상속받고 필요한 부분만 오버라이드 해준다

- 이제 새로운 화면을 위한 새로운 컨트롤러 클래스를 생성시작
- CrimeListActivity.java, CrimeListFragment.java 들을 생성하고 CrimeListActivity는 매니페스트에 선언
- CrimeListActivity를 런처 액티비티로 선언

- CrimeListFragment에서 범죄리스트를 사용자에게 보여주기 위해 RecyclerView를 사용
- RecyclerView는 ViewGroup의 서브 클래스로 자식 View 객체들의 리스트를 보여줌
- 우리 앱은 리스트에서 범죄의 제목만 보여줄 것이므로 자식 View 객체는 TextView 하나면 족하다
- RecyclerView는 한꺼번에 모든 View를 생성하는 것이 아닌 필요할 때만 View 객체를 생성할 수 있다
- 즉 한 화면을 채우는데 충분한 12개 정도만 먼저 생성하고 스크롤을 내려 View가 화면을 벗어나면 RecyclerView는 그 View를 버리지 않고 재활용한다

- 여기서 우리가 필요한 TextView를 얻으려면 Adapter의 서브 클래스와 ViewHolder의 서브 클래스가 함께 동작해야한다
- 먼저 ViewHolder는 하나의 View를 보존하는 일을 한다
- ViewHolder는 자신의 itemView로 View 객체를 가져옴
- RecyclerView는 자신이 ViewHolder를 생성하지 않고 어댑터에 요청한다. 어댑터는 컨트롤러의 객체이고
- 필요한 ViewHolder를 생성해주고 모델 계층의 데이터를 ViewHolder와 결합한다
- 그리고 RecyclerView가 화면에 보여줄 객체를 필요로 할때마다 자신의 어댑터와 소통한다 (메서드를 보내 데이터 요청)

- xml을 새로 만들어 RecyclerView 위젯으로 레이아웃을 구성하고 프래그먼트와 연결시킨다
- 어뎁터와 ViewHolder class 구현하기
- 어댑터에서 View 객체를 생성하고 ViewHolder를 만들어 여기에 넣는다
- 마지막으로 어댑터를 RecyclerView에 연결함

- 리스트항목 디자인을 커스터마이징 하고 싶으면 list_item_crime.xml을 따로 만들고 View들로 내용을 구성한다
- 그 후 추가한 View들을 연결하기 위해 어댑터와 ViewHolder를 수정
- list에 Toast 기능을 넣고 싶으면 ViewHolder에 View.OnClickListener 인터페이스를 impletments시키고
- setOnclickListener(this)를 추가한 후 onClick(View v) 메소드를 오버라이딩 한다


(10) 프래그먼트 인자 사용하기
- 여기서는 앱의 리스트와 디테일 부분이 함께 동작하게 할 것임
- 리스트의 항목을 클릭하면 CrimeFragment를 호스팅 하는 새로운 CrimeActivity가 나타나서 특정 Crime 인스턴스의 디테일을 보여줌
- 이때 명시적인 인텐트를 사용하여 Crime 객체를 인텐트 엑스트라 데이터로 전달할 것임

- 프래그먼트로부터 액티비티 시작시키기
- CrimeActivity에서 인텐트를 생성하고 엑스트라에 Crime의 데이터를 넣은 후
- Fragment.startActivity(Intent) 메서드를 호출하면됨

- 엑스트라 읽기
- 이제 Crime 객체 데이터는 CrimeActivity에 속한 인텐트에 저장되었다
- 하지만 그 엑스트라 데이터를 읽고 쓰는 것은 CrimeFragment이다
- 프래그먼트가 자신의 호스팅 하는 액티비티의 인텐트에 저장된 데이터에 액세스 할 수 있는 방법은 두가지
- 1. 쉽게 직접 엑세스하는법 : getActivity() 메서드를 사용해 인텐트를 바로 엑세스 => 재사용성 불가능
- 2. 복잡하지만 유연한 코드 구현 방법 : 프래그먼트에 속하는 프래그먼트의 인자(argument) 번들에 Crime 데이터를 저장
- 프래그먼트 인자를 생성하려면 우선 Bundle 객체를 생성하고 put 메서드를 사용해서 인자를 추가
- 인자 번들을 프래그먼트에 첨부하려면 Fragment.setArguments(Bundle)을 호출함
- 이를 위해 프래그먼트에 newInstance()라는 static 메서드를 추가하여 프래그먼트 인스턴스와 번들 인스턴스를 생성하고 번들 인스턴스를 프래그먼트 인자로 첨부한다. => 생성자를 직접 호출하는 대신 이 함수를 통해 생성하고 첨부하는 것

- 인자 가져오기
- 프래그먼트가 자신에게 전달된 인자를 엑세스해야할 때는 Fragment 클래스의 메서드인 getArguments()를 호출하고 Bundle의 ‘get’ 메서드들 중 하나를 호출하면 된다

- 여기까지하면 리스트에서 하나의 항목을 눌러 값을 가져올 수 있지만 디테일 화면에서 값을 변경 후 ‘back’ 버튼을 눌러 리스트로 돌아가면
- 변경 사항이 저장되지 않는다
- ‘back’을 누르면 디테일 화면 프래그먼트가 스택에서 꺼내져 소멸되고 다시 CrimeListActivity가 시작(started)되어 재실행(resumed) 되는데
- 재실행 될때 프래그먼트 매니저가 호스팅 하고 있는 프래그먼트들의 onResume()을 호출한다
- 즉 CrimeListFragment의 onResume() 메서드를 오버라이드하여 updateUI()를 호출하도록 수정해야함’

- 프래그먼트로부터 결과 받기
- 프래그먼트는 자신의 결과 값은 가질 수 없고 대신 호스팅 액티비티에 결과 값의 반환을 알려준다
